
#[derive(Copy, Clone, Debug)]
pub enum AddressMode {
    Accumulator,
    Absolute,
    AbsoluteX,
    AbsoluteY,
    Immediate,
    Implied,
    Indirect,
    XIndirect,
    IndirectY,
    Relative,
    Zeropage,
    ZeropageX,
    ZeropageY
}

impl AddressMode {
    pub fn get_asm(self, b: &[u8]) -> String {

        let b1 = *b.get(0).unwrap_or(&0);
        let b2 = *b.get(1).unwrap_or(&0);
        
        match self {
            Accumulator => "A".to_owned(),
            Absolute => format!("[0x{:X?}{:X?}]", b2, b1),
            AbsoluteX => format!("[0x{:X?}{:X?} + X]", b2, b1),
            AbsoluteY => format!("[0x{:X?}{:X?} + Y]", b2, b1),
            Immediate => format!("0x{:X?}", b1),
            Implied => "".to_owned(),
            Indirect => format!("[0x{:X?}{:X?}]", b2, b1),
            XIndirect => format!("[[{:X?} + X]]", b1),
            IndirectY => format!("[[{:X?}] + Y]", b1),
            Relative => format!("[PC + ({})]", b1 as i8),
            Zeropage => format!("[0x{:X?}]", b1),
            ZeropageX => format!("[0x{:X?} + X]", b1),
            ZeropageY => format!("[0x{:X?} + Y]", b1),
        }
    }

    pub fn operand_size(self) -> usize {
        match self {
            Accumulator => 0,
            Absolute => 2,
            AbsoluteX => 2,
            AbsoluteY => 2,
            Immediate => 1,
            Implied => 0,
            Indirect => 2,
            XIndirect => 1,
            IndirectY => 1,
            Relative => 1,
            Zeropage => 1,
            ZeropageX => 1,
            ZeropageY => 1,
        }
    }
}

#[derive(Copy, Clone, Debug)]
pub enum Instruction {
    ADC,
    ALR,
    ANC,
    AND,
    ANE,
    ARR,
    ASL,
    BCC,
    BCS,
    BEQ,
    BIT,
    BMI,
    BNE,
    BPL,
    BRK,
    BVC,
    BVS,
    CLC,
    CLD,
    CLI,
    CLV,
    CMP,
    CPX,
    CPY,
    DCP,
    DEC,
    DEX,
    DEY,
    EOR,
    INC,
    INX,
    INY,
    ISC,
    JMP,
    JSR,
    LAS,
    LAX,
    LDA,
    LDX,
    LDY,
    LSR,
    LXA,
    NOP,
    ORA,
    PHA,
    PHP,
    PLA,
    PLP,
    RLA,
    ROL,
    ROR,
    RRA,
    RTI,
    RTS,
    SAX,
    SBC,
    SBX,
    SEC,
    SED,
    SEI,
    SHA,
    SHX,
    SHY,
    SLO,
    SRE,
    STA,
    STX,
    STY,
    TAS,
    TAX,
    TAY,
    TSX,
    TXA,
    TXS,
    TYA,
    USB,
    XXX,
}

impl Instruction {
    pub fn description(self) -> &'static str {
        match self {
            ADC => "Add with carry",
            ALR => "AND + LSR",
            ANC => "AND + set C",
            AND => "And",
            ANE => "* AND X + AND oper",
            ARR => "AND + ROR",
            ASL => "Arithmetic shift left",
            BCC => "Branch on carry clear",
            BCS => "Branch on carry set",
            BEQ => "Branch on equal",
            BIT => "Bit test",
            BMI => "Branch on minus",
            BNE => "Branch on not equal",
            BPL => "Branch on plus",
            BRK => "Break / interrupt",
            BVC => "Branch on overflow clear",
            BVS => "Branch on overflow set",
            CLC => "Clear carry",
            CLD => "Clear decimal",
            CLI => "Clear interrupt disable",
            CLV => "Clear overflow",
            CMP => "Compare with accumulator",
            CPX => "Compare with X",
            CPY => "Compare with Y",
            DCP => "DEC + CMP",
            DEC => "Decrement",
            DEX => "Decrement X",
            DEY => "Decrement Y",
            EOR => "Exclusive or",
            INC => "Increment",
            INX => "Increment X",
            INY => "Increment Y",
            ISC => "INC + SBC",
            JMP => "Jump",
            JSR => "Jump subroutine",
            LAS => "LDA/TSX M",
            LAX => "LDA + LDX",
            LDA => "Load accumulator",
            LDX => "Load X",
            LDY => "Load Y",
            LSR => "Logical shift right",
            LXA => "LDA + LDX",
            NOP => "No operation",
            ORA => "Or with accumulator",
            PHA => "Push accumulator onto stack",
            PHP => "Push processor status onto stack",
            PLA => "Pull accumulator from stack",
            PLP => "Pull processor status from stack",
            RLA => "ROL + AND",
            ROL => "Rotate left",
            ROR => "Rotate right",
            RRA => "ROR + ADC",
            RTI => "Return from interrupt",
            RTS => "Return from subroutine",
            SAX => "Store acc. AND X",
            SBC => "Subtract with carry",
            SBX => "X = (acc. AND X) + SBC",
            SEC => "Set carry",
            SED => "Set decimal",
            SEI => "Set interrupt disable",
            SHA => "Store acc. AND X AND (hi-addr.+1)",
            SHX => "Store A AND X AND (hi-addr.+1)",
            SHY => "Store Y AND (hi-addr.+1)",
            SLO => "Store ASL + ORA",
            SRE => "Store LSR + EOR",
            STA => "Store accumulator",
            STX => "Store X",
            STY => "Store Y",
            TAS => "Transfer acc. AND X to SP,",
            TAX => "Transfer accumulator to X",
            TAY => "Transfer accumulator to Y",
            TSX => "Transfer stack pointer to X",
            TXA => "Transfer X to accumulator",
            TXS => "Transfer X to stack pointer",
            TYA => "Transfer Y to accumulator",
            USB => "SBC + NOP",
            XXX => "error!"

        }
    }
}

#[derive(Copy, Clone, Debug)]
pub struct Opcode {
    pub instruction: Instruction,
    pub mode: AddressMode,
    pub cycles: u32,
}


use AddressMode::*;
use Instruction::*;

macro_rules! op {
    ( $instruction:expr, $mode:expr, $cycles:expr ) => {
        Opcode {
            instruction: $instruction,
            mode: $mode,
            cycles: $cycles,
        }
    };
}

pub static OPCODES: &'static [Opcode] = &[
    op!(BRK, Implied, 1),
    op!(ORA, XIndirect, 1),
    op!(XXX, Implied, 1),
    op!(SLO, XIndirect, 1),
    op!(NOP, Zeropage, 1),
    op!(ORA, Zeropage, 1),
    op!(ASL, Zeropage, 1),
    op!(SLO, Zeropage, 1),
    op!(PHP, Implied, 1),
    op!(ORA, Immediate, 1),
    op!(ASL, Accumulator, 1),
    op!(ANC, Immediate, 1),
    op!(NOP, Absolute, 1),
    op!(ORA, Absolute, 1),
    op!(ASL, Absolute, 1),
    op!(SLO, Absolute, 1),
    op!(BPL, Relative, 1),
    op!(ORA, IndirectY, 1),
    op!(XXX, Implied, 1),
    op!(SLO, IndirectY, 1),
    op!(NOP, ZeropageX, 1),
    op!(ORA, ZeropageX, 1),
    op!(ASL, ZeropageX, 1),
    op!(SLO, ZeropageX, 1),
    op!(CLC, Implied, 1),
    op!(ORA, AbsoluteY, 1),
    op!(NOP, Implied, 1),
    op!(SLO, AbsoluteY, 1),
    op!(NOP, AbsoluteX, 1),
    op!(ORA, AbsoluteX, 1),
    op!(ASL, AbsoluteX, 1),
    op!(SLO, AbsoluteX, 1),
    op!(JSR, Absolute, 1),
    op!(AND, XIndirect, 1),
    op!(XXX, Implied, 1),
    op!(RLA, XIndirect, 1),
    op!(BIT, Zeropage, 1),
    op!(AND, Zeropage, 1),
    op!(ROL, Zeropage, 1),
    op!(RLA, Zeropage, 1),
    op!(PLP, Implied, 1),
    op!(AND, Immediate, 1),
    op!(ROL, Accumulator, 1),
    op!(ANC, Immediate, 1),
    op!(BIT, Absolute, 1),
    op!(AND, Absolute, 1),
    op!(ROL, Absolute, 1),
    op!(RLA, Absolute, 1),
    op!(BMI, Relative, 1),
    op!(AND, IndirectY, 1),
    op!(XXX, Implied, 1),
    op!(RLA, IndirectY, 1),
    op!(NOP, ZeropageX, 1),
    op!(AND, ZeropageX, 1),
    op!(ROL, ZeropageX, 1),
    op!(RLA, ZeropageX, 1),
    op!(SEC, Implied, 1),
    op!(AND, AbsoluteY, 1),
    op!(NOP, Implied, 1),
    op!(RLA, AbsoluteY, 1),
    op!(NOP, AbsoluteX, 1),
    op!(AND, AbsoluteX, 1),
    op!(ROL, AbsoluteX, 1),
    op!(RLA, AbsoluteX, 1),
    op!(RTI, Implied, 1),
    op!(EOR, XIndirect, 1),
    op!(XXX, Implied, 1),
    op!(SRE, XIndirect, 1),
    op!(NOP, Zeropage, 1),
    op!(EOR, Zeropage, 1),
    op!(LSR, Zeropage, 1),
    op!(SRE, Zeropage, 1),
    op!(PHA, Implied, 1),
    op!(EOR, Immediate, 1),
    op!(LSR, Accumulator, 1),
    op!(ALR, Immediate, 1),
    op!(JMP, Absolute, 1),
    op!(EOR, Absolute, 1),
    op!(LSR, Absolute, 1),
    op!(SRE, Absolute, 1),
    op!(BVC, Relative, 1),
    op!(EOR, IndirectY, 1),
    op!(XXX, Implied, 1),
    op!(SRE, IndirectY, 1),
    op!(NOP, ZeropageX, 1),
    op!(EOR, ZeropageX, 1),
    op!(LSR, ZeropageX, 1),
    op!(SRE, ZeropageX, 1),
    op!(CLI, Implied, 1),
    op!(EOR, AbsoluteY, 1),
    op!(NOP, Implied, 1),
    op!(SRE, AbsoluteY, 1),
    op!(NOP, AbsoluteX, 1),
    op!(EOR, AbsoluteX, 1),
    op!(LSR, AbsoluteX, 1),
    op!(SRE, AbsoluteX, 1),
    op!(RTS, Implied, 1),
    op!(ADC, XIndirect, 1),
    op!(XXX, Implied, 1),
    op!(RRA, XIndirect, 1),
    op!(NOP, Zeropage, 1),
    op!(ADC, Zeropage, 1),
    op!(ROR, Zeropage, 1),
    op!(RRA, Zeropage, 1),
    op!(PLA, Implied, 1),
    op!(ADC, Immediate, 1),
    op!(ROR, Accumulator, 1),
    op!(ARR, Immediate, 1),
    op!(JMP, Indirect, 1),
    op!(ADC, Absolute, 1),
    op!(ROR, Absolute, 1),
    op!(RRA, Absolute, 1),
    op!(BVS, Relative, 1),
    op!(ADC, IndirectY, 1),
    op!(XXX, Implied, 1),
    op!(RRA, IndirectY, 1),
    op!(NOP, ZeropageX, 1),
    op!(ADC, ZeropageX, 1),
    op!(ROR, ZeropageX, 1),
    op!(RRA, ZeropageX, 1),
    op!(SEI, Implied, 1),
    op!(ADC, AbsoluteY, 1),
    op!(NOP, Implied, 1),
    op!(RRA, AbsoluteY, 1),
    op!(NOP, AbsoluteX, 1),
    op!(ADC, AbsoluteX, 1),
    op!(ROR, AbsoluteX, 1),
    op!(RRA, AbsoluteX, 1),
    op!(NOP, Immediate, 1),
    op!(STA, XIndirect, 1),
    op!(NOP, Immediate, 1),
    op!(SAX, XIndirect, 1),
    op!(STY, Zeropage, 1),
    op!(STA, Zeropage, 1),
    op!(STX, Zeropage, 1),
    op!(SAX, Zeropage, 1),
    op!(DEY, Implied, 1),
    op!(NOP, Immediate, 1),
    op!(TXA, Implied, 1),
    op!(ANE, Immediate, 1),
    op!(STY, Absolute, 1),
    op!(STA, Absolute, 1),
    op!(STX, Absolute, 1),
    op!(SAX, Absolute, 1),
    op!(BCC, Relative, 1),
    op!(STA, IndirectY, 1),
    op!(XXX, Implied, 1),
    op!(SHA, IndirectY, 1),
    op!(STY, ZeropageX, 1),
    op!(STA, ZeropageX, 1),
    op!(STX, ZeropageY, 1),
    op!(SAX, ZeropageY, 1),
    op!(TYA, Implied, 1),
    op!(STA, AbsoluteY, 1),
    op!(TXS, Implied, 1),
    op!(TAS, AbsoluteY, 1),
    op!(SHY, AbsoluteX, 1),
    op!(STA, AbsoluteX, 1),
    op!(SHX, AbsoluteY, 1),
    op!(SHA, AbsoluteY, 1),
    op!(LDY, Immediate, 1),
    op!(LDA, XIndirect, 1),
    op!(LDX, Immediate, 1),
    op!(LAX, XIndirect, 1),
    op!(LDY, Zeropage, 1),
    op!(LDA, Zeropage, 1),
    op!(LDX, Zeropage, 1),
    op!(LAX, Zeropage, 1),
    op!(TAY, Implied, 1),
    op!(LDA, Immediate, 1),
    op!(TAX, Implied, 1),
    op!(LXA, Immediate, 1),
    op!(LDY, Absolute, 1),
    op!(LDA, Absolute, 1),
    op!(LDX, Absolute, 1),
    op!(LAX, Absolute, 1),
    op!(BCS, Relative, 1),
    op!(LDA, IndirectY, 1),
    op!(XXX, Implied, 1),
    op!(LAX, IndirectY, 1),
    op!(LDY, ZeropageX, 1),
    op!(LDA, ZeropageX, 1),
    op!(LDX, ZeropageY, 1),
    op!(LAX, ZeropageY, 1),
    op!(CLV, Implied, 1),
    op!(LDA, AbsoluteY, 1),
    op!(TSX, Implied, 1),
    op!(LAS, AbsoluteY, 1),
    op!(LDY, AbsoluteX, 1),
    op!(LDA, AbsoluteX, 1),
    op!(LDX, AbsoluteY, 1),
    op!(LAX, AbsoluteY, 1),
    op!(CPY, Immediate, 1),
    op!(CMP, XIndirect, 1),
    op!(NOP, Immediate, 1),
    op!(DCP, XIndirect, 1),
    op!(CPY, Zeropage, 1),
    op!(CMP, Zeropage, 1),
    op!(DEC, Zeropage, 1),
    op!(DCP, Zeropage, 1),
    op!(INY, Implied, 1),
    op!(CMP, Immediate, 1),
    op!(DEX, Implied, 1),
    op!(SBX, Immediate, 1),
    op!(CPY, Absolute, 1),
    op!(CMP, Absolute, 1),
    op!(DEC, Absolute, 1),
    op!(DCP, Absolute, 1),
    op!(BNE, Relative, 1),
    op!(CMP, IndirectY, 1),
    op!(XXX, Implied, 1),
    op!(DCP, IndirectY, 1),
    op!(NOP, ZeropageX, 1),
    op!(CMP, ZeropageX, 1),
    op!(DEC, ZeropageX, 1),
    op!(DCP, ZeropageX, 1),
    op!(CLD, Implied, 1),
    op!(CMP, AbsoluteY, 1),
    op!(NOP, Implied, 1),
    op!(DCP, AbsoluteY, 1),
    op!(NOP, AbsoluteX, 1),
    op!(CMP, AbsoluteX, 1),
    op!(DEC, AbsoluteX, 1),
    op!(DCP, AbsoluteX, 1),
    op!(CPX, Immediate, 1),
    op!(SBC, XIndirect, 1),
    op!(NOP, Immediate, 1),
    op!(ISC, XIndirect, 1),
    op!(CPX, Zeropage, 1),
    op!(SBC, Zeropage, 1),
    op!(INC, Zeropage, 1),
    op!(ISC, Zeropage, 1),
    op!(INX, Implied, 1),
    op!(SBC, Immediate, 1),
    op!(NOP, Implied, 1),
    op!(USB, Immediate, 1),
    op!(CPX, Absolute, 1),
    op!(SBC, Absolute, 1),
    op!(INC, Absolute, 1),
    op!(ISC, Absolute, 1),
    op!(BEQ, Relative, 1),
    op!(SBC, IndirectY, 1),
    op!(XXX, Implied, 1),
    op!(ISC, IndirectY, 1),
    op!(NOP, ZeropageX, 1),
    op!(SBC, ZeropageX, 1),
    op!(INC, ZeropageX, 1),
    op!(ISC, ZeropageX, 1),
    op!(SED, Implied, 1),
    op!(SBC, AbsoluteY, 1),
    op!(NOP, Implied, 1),
    op!(ISC, AbsoluteY, 1),
    op!(NOP, AbsoluteX, 1),
    op!(SBC, AbsoluteX, 1),
    op!(INC, AbsoluteX, 1),
    op!(ISC, AbsoluteX, 1),
];
